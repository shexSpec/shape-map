<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>ShapeMap API, Structure and Language</title>
    <!-- link rel="stylesheet" href="css/wgio.min.css"/ ask Iovka -->
    <link rel="stylesheet" href="../spec/local.css"/>
    <style>
      .error { border: medium solid #efe7e7; }
      .error { background-color: #fff7f7; }
    </style>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>

    <script class='remove'>
      var respecConfig = {
      localBiblio: {
        "shex-semantics": {
          "authors": ["Gregg Kellogg"],
          "title": "Shape Expression Language",
          "href":  "http://shex.io/semantics"
        }
      },
      specStatus:     "CG-DRAFT",
      shortName:      "shapemap",
      edDraftURI:     "https://shexspec.github.io/ShapeMap/",
      testSuiteURI:   "https://github.com/shexSpec/shexTest",
      issueBase:      "https://github.com/shexSpec/shex/issues",
      githubAPI:      "https://api.github.com/repos/shexSpec/shex",
      editors: [
        { name:       "Eric Prud'hommeaux",
          url:        "http://www.w3.org/People/Eric/",
          company:    "W3C/MIT",
          companyURL: "http://www.w3.org/" },
      ],
      wg:           "Shape Expressions Community Group",
      wgURI:        "https://www.w3.org/community/shex/",
      wgPublicList: "public-shex",
      //wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",

      bugTracker:             {
        open: "https://github.com/shexSpec/ShapeMap/issues",
        new:  "https://github.com/shexSpec/ShapeMap/issues/new"
      },

      otherLinks: [{
        key: "Version control",
        data: [{
          value: "Github Repository",
          href: "https://github.com/shexSpec/ShapeMap"
        }]
      }],
      };
    </script>

    <script type="text/javascript" src="scripts.js"></script>
  </head>
  
  <body>
    <section id="abstract">
      <p>
        The Shape Expressions (ShEx) language describes <a>RDF nodes</a> and <a>graph</a> structures.
        A <span class="math">node constraint</span> describes an RDF node (<a>IRI</a>, <a>blank node</a> or <a>literal</a>) and a <span class="math">shape</span> describes the <a>triples</a> involving nodes in an <a>RDF graph</a>.
        The ShapeMap language associates RDF nodes with ShEx shapes.
        These associations can be used to state candidate shape maps as an input to the validation process.
        They can be the output of a validation process, where the ShEx engine reports the conformance of RDF nodes with respect to ShEx Shapes.
      </p>
      <p>
        This document defines the ShapeMap language.
        See the <a href="../primer/index.html">Shape Expressions Primer</a> for an introduction to ShEx validation and the <a href="../spec/index.html">Shape Expressions Language</a> for a formal definition of ShEx.
      </p>
    </section>

    <section id="sotd">
      <p>This document has been developed by the
        <a href="https://www.w3.org/community/shex/">Shape Expressions Community Group</a>.
      </p>

      <p>This version is an initial editor's proposal to the CG.</p>
    </section>

    <section id="notation">
      <h2>Notation and Terminology</h2>
      <p>
        This document assumes an understanding of the ShEx notation and terminology.
        Please see the associated sections of the <a href="../spec/index.html">Shape Expressions Language</a>.
      </p>
      <ul>
        <li><dfn data-cite="shex-semantics#dfn-shapeexpr" data-lt="shape expression|shex shape expression">ShapeExpression</dfn>: a boolean expression of ShEx shapes.</li>
        <li><dfn data-lt="focus node|focus">focus node</dfn>: a node, potentially in an RDF graph, to be inspected for conformance with a shape expression.</li>
      </ul>
      <p>
        ShExMap uses the following terms from RDF semantics [[!rdf11-mt]]:
      </p>
      <ul>
        <li><dfn data-cite="rdf11-concepts#dfn-node" data-lt="rdf node|rdf nodes">Node</dfn>: one of <dfn>IRI</dfn>, <dfn data-cite="rdf11-concepts#dfn-blank-node">blank node</dfn>, <dfn>Literal</dfn></li>
        <li><dfn data-cite="rdf11-concepts#dfn-rdf-graph" data-lt="RDF Graph|RDF Graphs">Graph</dfn>: a set of <dfn data-cite="rdf11-concepts#dfn-rdf-triple" data-lt="triple|rdf triple|rdf triples">Triples</dfn> of (<dfn data-cite="rdf11-concepts#dfn-subject">subject</dfn>, <dfn data-cite="rdf11-concepts#dfn-predicate">predicate</dfn>, <dfn data-cite="rdf11-concepts#dfn-object">object</dfn>)</li>
      </ul>
      <p>Validation type definition:
        <ul>
          <li><b>Primary validation: </b> Validation of node against a shape of which the mapping is present in the shape map</il>
          <li><b>Recursive validation: </b> Validation of node against a shape, which triggered via the validation of another shape.</il> 
        </ul>
      </p>
    </section>

    <section id="conformance">
      <p>Conformance criteria are relevant to authors and authoring tool implementers. As well
        as sections marked as non-normative, all authoring guidelines, diagrams, examples,
        and notes in this specification are non-normative. Everything else in this
        specification is normative.</p>

      <ul>
        <li>A <a>ShapeMap</a> document complies with this specification if it
          conforms to the grammar described in <a href="#grammar" class="sectionRef"></a> resulting
          in a valid <a>ShapeMap</a> structure.</li>
      </ul>
    </section>

    <section id="appInterface">
    <h2>The Application Programming Interface</h2><p><em>This section is non-normative.</em></p>
    
    
    

      <p>This API provides a clean mechanism that enables developers to determine
        conformance of <a>RDF Graphs</a> to a ShEx <a>Schema</a>.</p>

      <p>The ShEx async API uses <a>Promises</a> to represent
        the result of the various asynchronous operations.
        <a data-cite="ECMASCRIPT-6.0#sec-promise-objects">Promises</a> are defined in [[ECMASCRIPT-6.0]].
        General use within specifications can be found in [[promises-guide]].</p>

       <section>
        <h3>The <dfn>ShExProcessor</dfn> Interface</h3><p><em>This section is non-normative.</em></p>
	
	   
        <p>The <a>ShExProcessor</a> interface is the high-level programming structure
          that developers use to determine
          <a>conformance</a> of <a>RDF Graphs</a> to a ShEx <a>Schema</a>.</p>

        <p>It is important to highlight that implementations do not modify the input parameters.
          If an error is detected, the <a>Promise</a> is
          rejected passing a <a>ShExError</a> with the corresponding error
          <a data-link-for="ShExError">code</a>.</p>

        <div><button title="Copy IDL to clipboard" class="respec-button-copy-paste removeOnSave" data-clipboard-target="#idl-def-shexprocessor"><svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg></button><pre class="def idl"><span class="idlInterface" id="idl-def-shexprocessor" data-idl="" data-title="ShExProcessor">[<span class="idlCtor"><span class="extAttrName"><a data-cite="WEBIDL#Constructor">Constructor</a></span></span>]
interface <span class="idlInterfaceID">ShExProcessor</span> {
<span class="idlMethod" id="idl-def-shexprocessor-validate(schema,graph,shapemap,options)" data-idl="" data-title="validate" data-dfn-for="shexprocessor">    <span class="idlMethType"><a data-cite="WEBIDL#idl-promise">ByteString</a></span> <span class="idlMethName">validate</span>(<span class="idlParam"><span class="idlParamType"><a data-cite="WEBIDL#idl-ByteString">ByteString</a></span> <span class="idlParamName">schema</span></span>,
                     <span class="idlParam"><span class="idlParamType">(<a data-cite="WEBIDL#idl-ByteString">ByteString</a> or <a>RDFGraph</a>)</span> <span class="idlParamName">graph</span></span>,
                     <span class="idlParam">optional <span class="idlParamType"><a>ByteString</a></span> <span class="idlParamName">shapeMap</span></span>,
                     <span class="idlParam">optional <span class="idlParamType"><a>ShExOptions</a></span> <span class="idlParamName">options</span></span>) raises(ShExError);</span>
};</span></pre></div>

        <dl>
          <dt><dfn data-lt="ShExProcessor.validate" data-lt-nodefault="">validate</dfn></dt><dd>
            Checks <a>conformance</a> of the given <a data-lt="ShExProcessor.validate.graph">validate.graph</a>
            with <a data-lt="ShExProcessor.validate.schema">validate.schema</a> using
            <a data-lt="ShExProcessor.validate.shapeMap">validate.shapeMap</a> according to
            <a href="#validation-requirement" class="sectionRef"></a>.

            <ol class="algorithm">
              <li>Parse the <a data-lt="ShExProcessor.validate.schema">validate.schema</a> as given by the <a data-link-for="ShExOptions">formatSchema</a>.
                In case of unresolvable URI raise ShExError with code 'URI unresolvable'.
                In case of a parser syntax error raise ShExError with code 'syntax error'.
                In case of error in the schema raise ShExError with code 'invalid schema'
             <li>Parse the <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as given by the <a data-link-for="ShExOptions">formatGraph</a>. If <a>RDFGraph</a> is supplied ignore the <a data-link-for="ShExOptions">formatGraph</a> option. 
                 In case of unresolvable URI raise ShExError with code 'URI unresolvable'.
                 In case of a parser syntax error raise ShExError with code 'syntax error'.
               </li>
              <li>If shapeMap is null, create empty shape map.</li>
              <li>Parse the shapeMap parameter as <a data-lt="#shapemap-structure">ShapeMap</a>, if syntax error raise ShExError with code 'invalid shape map'.</li>
              <li>Add a mapping to the shape map for each element in the option <a data-link-for="ShExOptions">focusNodes</a> to the start node in the schema with the status 'open'.</li>
              <li>Validate if the shape map does not contain duplicate entries, otherwise throw ShExError with code 'duplicated mapping'.</li>
              <li>Repeat until resulting shape map does not contain any mappings with status 'open': For each mapping in the shape map with the status 'open' perform
                validation using <em>schema</em> and <em>graph</em> according to the requirements in
                <a href="#validation-requirement" class="sectionRef"></a>. Negate result if the 'negate' property == true. Store any validation failures into the 'appinfo' and 'reason' properties.
                Any additional mappings created due to recursive validation will be added to the resulting shape map, if option 'enableExpansion' == true. <br><br>
                NOTE: All entries within the shape map with status 'conformant' or 'nonconformant', will cause the validator to use these result and not perform a (recursive) validation of the mapping.</li>
              <li>Encode and return the resulting shapeMap with the encoding given in <a data-lt="#shapemap-structure">ShapeMap</a></li>
            </ol>

            <dl class="parameters">
              <dt><dfn data-lt="ShExProcessor.validate.schema" data-lt-nodefault="">schema</dfn></dt>
              <dd>The ShEx Schema, either as a dereferencable <a>IRI</a> (URL), an inline data string, or an <a>RDF Graph</a>
               which is transformed into the <a>ShExJ</a> abstract syntax.</dd>
              <dt><dfn data-lt="ShExProcessor.validate.graph" data-lt-nodefault="">graph</dfn></dt>
              <dd>The graph to check <a>conformance</a> with, either as a a dereferencable <a>IRI</a> to some RDF serialization,
                or as an accessable <a>RDF Graph</a>.</dd>
              <dt><dfn data-lt="ShExProcessor.validate.shapeMap" data-lt-nodefault="">shapeMap</dfn></dt>
              <dd>A string representing the input shape map according to the encoding given in <a data-lt="#shapemap-structure">ShapeMap</a></dd>
              <dt><dfn data-lt="ShExProcessor.validate.options" data-lt-nodefault="">options</dfn></dt>
              <dd>A set of options to configure the algorithms.</dd>
              <dt><dfn data-lt="ShExProcessor.validate.options" data-lt-nodefault="">returns</dfn></dt>
              <dd>A string representing the resulting shape map according to the encoding given in <a data-lt="#shapemap-structure">ShapeMap</a></dd>              
            </dl>
          </dd>
        </dl>
        <span class="ednote">ISSUE: What to do if a conflict occurs between a mapping in the mapping file that states that node X must not conform to shape Y, where as a 
        recursive validation states otherwise (node X must conform to shape Y)</span>
        <span class="ednote">ISSUE: Add async version of the validate function based on the promise construct, I think the sync version of validate should be mandatory,
        whereas the async version should be an optional implementation. </span> <br>
        <span class="ednote">ISSUE: Add a json representation (defined with IDL definitions) for the shape map instead of only the encoding given in <a data-lt="#shapemap-structure">ShapeMap</a>. </span>
      </section> <!-- end of ShExProcessor -->

      <section>
        <h3>The RDFGraph Type</h3><p><em>This section is non-normative.</em></p>

        <p>The <dfn>RDFGraph</dfn> type is describe an <a>RDF Graph</a> accessed
          as described in <a href="#graph-access" class="sectionRef">Graph access</a>.</p>

        <div><button title="Copy IDL to clipboard" class="respec-button-copy-paste removeOnSave" data-clipboard-target="#idl-def-rdfgraph"><svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg></button><pre class="def idl"><span class="idlInterface" id="idl-def-rdfgraph" data-idl="" data-title="RDFGraph">interface <span class="idlInterfaceID">RDFGraph</span> {
<span class="idlMethod" id="idl-def-rdfgraph-bgp()" data-idl="" data-title="bgp" data-dfn-for="rdfgraph">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName">bgp</span>(ByteString subj,ByteString pred,ByteString obj,ByteString objType);</span>
};</span></pre></div>

        <dl data-dfn-for="RDFGraph">
          <dt><dfn>bgp</dfn></dt><dd>
            Performs a <a data-cite="sparql11-query#BGPsparql">SPARQL Basic Graph Pattern</a> query on the graph.
          </dd>
        </dl>
           <span class="ednote">TODO: define function as callback and complete the description</span>
     </section>

      <section>
        <h3>The ShExOptions Type</h3><p><em>This section is non-normative.</em></p>

        <p>The <dfn>ShExOptions</dfn> type is used to pass various options to the
          <a>ShExProcessor</a> methods.</p>

        <div><button title="Copy IDL to clipboard" class="respec-button-copy-paste removeOnSave" data-clipboard-target="#idl-def-shexoptions"><svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg></button><pre class="def idl"><span class="idlDictionary" id="idl-def-shexoptions" data-idl="" data-title="ShExOptions">dictionary <span class="idlDictionaryID">ShExOptions</span> {
<span class="idlMember" id="idl-def-shexoptions-base" data-idl="" data-title="base" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-ByteString">ByteString</a>?</span> <span class="idlMemberName">base</span>;</span>
<span class="idlMember" id="idl-def-shexoptions-focusnodes" data-idl="" data-title="focusNodes" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-sequence">sequence</a>&lt;ByteString&gt;?</span>  <span class="idlMemberName">focusNodes</span>;</span>
<span class="idlMember" id="idl-def-shexoptions-formatSchema" data-idl="" data-title="formatSchema" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-ByteString">ByteString</a></span>  <span class="idlMemberName">formatSchema</span> = <span class="idlMemberValue">"ShExC"</span>;</span>
<span class="idlMember" id="idl-def-shexoptions-formatGraph" data-idl="" data-title="formatGraph" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-ByteString">ByteString</a></span>  <span class="idlMemberName">formatGraph</span> = <span class="idlMemberValue">"Turtle"</span>;</span>
<span class="idlMember" id="idl-def-shexoptions-processingmode" data-idl="" data-title="processingMode" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-ByteString">ByteString</a></span>  <span class="idlMemberName">processingMode</span> = <span class="idlMemberValue">"shex-2.0"</span>;</span>
<span class="idlMember" id="idl-def-shexoptions-enableExpansion" data-idl="" data-title="enableExpansion" data-dfn-for="shexoptions">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-ByteString">boolean</a></span>  <span class="idlMemberName">enableExpansion</span> = <span class="idlMemberValue">true</span>;</span>
};</span></pre></div>

        <dl>
          <dt><dfn data-dfn-for="ShExOptions">base</dfn></dt>
          <dd>The base IRI to use when parsing <a data-lt="ShExProcessor.validate.schema">validate.schema</a>. If set, this overrides
            the <a data-lt="ShExProcessor.validate.schema">validate.schema</a>'s IRI.</dd>
          <dt><dfn data-dfn-for="ShExOptions">focusNodes</dfn></dt>
          <dd>A list of one or more <a>node</a> or <a>node selector</a> referencing to nodes in the
            <a data-lt="ShExProcessor.validate.graph">validate.graph</a> which
            are are checked for <a>conformance</a> against the <a>start</a> shape defined in the <a data-lt="ShExProcessor.validate.schema">validate.schema</a>.</dd>
          <dt><dfn data-dfn-for="ShExOptions">formatSchema</dfn></dt>
          <dd>One of: 
            <ul>
              <li><code>ShExC</code>: Parse <a data-lt="ShExProcessor.validate.schema">validate.schema</a> as ShExC.</li>
              <li><code>ShExJ</code>: Parse <a data-lt="ShExProcessor.validate.schema">validate.schema</a> as ShExJ.</li>
              <li><code>URI</code>: Resolve <a data-lt="ShExProcessor.validate.schema">validate.schema</a> and use content type to determine type</li>
              <li><code>URI/ShExJ</code>: Resolve <a data-lt="ShExProcessor.validate.schema">validate.schema</a> and then parse result as ShExJ.</li>
              <li><code>URI/ShExC</code>: Resolve <a data-lt="ShExProcessor.validate.schema">validate.schema</a> and then parse result as ShExC.</li>
            </ul>
            <span class="ednote">NOTE: left out option 'AUTOMATIC', because of potential security issues.</span>  <br> 
            <span class="ednote">TODO: turn into enumeration</span> <br>
            <span class="ednote">TODO: add ShExR with different RDF encodings</span>                
          </dd>
          <dt><dfn data-dfn-for="ShExOptions">formatGraph</dfn></dt>
          <dd>One of: 
            <ul>
              <li><code>RDF/XML</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as RDF/XML.</li>
              <li><code>Turtle</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as Turtle.</li>
              <li><code>N-Triples</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as N-Triples.</li>
              <li><code>N3</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as N3.</li>
              <li><code>RDF/JSON</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as RDF/JSON.</li>
              <li><code>JSON-LD</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as JSON-LD.</li>
              <li><code>RDF-THRIFT</code>: Parse <a data-lt="ShExProcessor.validate.graph">validate.graph</a> as RDF-THRIFT.</li>
              <li><code>URI</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and use content type to determine type</li>
              <li><code>URI/RDF/XML</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as RDF/XML.</li>
              <li><code>URI/Turtle</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as Turtle.</li>
              <li><code>URI/N-Triples</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as N-Triples.</li>
              <li><code>URI/N3</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as N3.</li>
              <li><code>URI/RDF/JSON</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as RDF/JSON.</li>
              <li><code>URI/JSON-LD</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as JSON-LD.</li>
              <li><code>URI/RDF-THRIFT</code>: Resolve <a data-lt="ShExProcessor.validate.graph">validate.graph</a> and then parse result as RDF-THRIFT.</li>
              <li><code>SPARQL</code>: <a data-lt="ShExProcessor.validate.graph">validate.graph</a> is the URI of a sparql endpoint. Validator will fire SPARQL queries to validate. (option for 2.1?)</li>
            </ul>
            <span class="ednote">NOTE: left out option 'AUTOMATIC', because of potential security issues.</span><br>   
            <span class="ednote">TODO: turn into enumeration</span>                
          </dd>
          <dt><dfn data-dfn-for="ShExOptions">processingMode</dfn></dt>
          <dd>If set to <code>shex-2.0</code>, the implementation has to produce
            exactly the same results as the algorithms defined in this specification.
            If set to another value, the ShEx processor is allowed to extend
            or modify the algorithms defined in this specification to enable
            application-specific optimizations. The definition of such
            optimizations is beyond the scope of this specification and thus
            not defined. Consequently, different implementations may implement
            different optimizations. Developers must not define modes beginning
            with <code>shex</code> as they are reserved for future versions
            of this specification.</dd>
          <dt><dfn data-dfn-for="ShExOptions">enableExpansion</dfn></dt>
          <dd>If enabled, any recursive validations potentially triggering new node to shape mapping will be added to the shape map. 
           If disabled any unknown mappings will automatically return false in validation process. 
           However, recursive validation will proceed for mappings that are in the shape map with the 'open' status (even when expansion is disabled).</dd>
        </dl>
      </section> <!-- end ShExOptions -->

        <section>
          <h4>ShExError</h4>

          <p>The <dfn>ShExError</dfn> type is used to report processing errors.</p>

          <div><button title="Copy IDL to clipboard" class="respec-button-copy-paste removeOnSave" data-clipboard-target="#idl-def-shexerror"><svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg></button><pre class="def idl"><span class="idlDictionary" id="idl-def-shexerror" data-idl="" data-title="ShExError">dictionary <span class="idlDictionaryID">ShExError</span> {
<span class="idlMember" id="idl-def-shexerror-code" data-idl="" data-title="code" data-dfn-for="shexerror">    <span class="idlMemberType"><a>ShExErrorCode</a></span> <span class="idlMemberName">code</span>;</span>
<span class="idlMember" id="idl-def-shexerror-message" data-idl="" data-title="message" data-dfn-for="shexerror">    <span class="idlMemberType"><a data-cite="WEBIDL#idl-DOMString">DOMString</a>?</span>    <span class="idlMemberName">message</span> = <span class="idlMemberValue">null</span>;</span>
};</span></pre></div>

          <dl>
            <dt><dfn data-dfn-for="ShExError">code</dfn></dt>
            <dd>a string representing the particular error type, as described in
              the various algorithms in this document.</dd>
            <dt><dfn data-dfn-for="ShExError">message</dfn></dt>
            <dd>an optional error message containing additional debugging information.
              The specific contents of error messages are outside the scope of this
              specification.</dd>
          </dl>
         </section>

        <section class="informative">
          <h4>ShExErrorCode</h4>
          <p>The <dfn>ShExErrorCode</dfn> represents the collection of valid ShEx error
            codes.</p>

          <div><button title="Copy IDL to clipboard" class="respec-button-copy-paste removeOnSave" data-clipboard-target="#idl-def-shexerrorcode"><svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"></path></svg></button><pre class="def idl"><span class="idlEnum" id="idl-def-shexerrorcode" data-idl="" data-title="ShExErrorCode">enum <span class="idlEnumID">ShExErrorCode</span> {
    <a href="#dom-shexerrorcode-invalid schema" class="idlEnumItem">"invalid schema"</a>,
    <a href="#dom-shexerrorcode-non-conforming graph" class="idlEnumItem">"non-conforming graph"</a>,
    <a href="#dom-shexerrorcode-syntax error" class="idlEnumItem">"syntax error"</a>,
    <a href="#dom-shexerrorcode-invalid shape map" class="idlEnumItem">"invalid shape map"</a>,
    <a href="#dom-shexerrorcode-duplicated mapping" class="idlEnumItem">"duplicated mapping"</a>
    <a href="#dom-shexerrorcode-duplicated URI unresolvable" class="idlEnumItem">"URI unresolvable"</a>
    
    
};</span></pre></div>

          <dl data-dfn-for="ShExErrorCode">
            <dt><dfn>invalid schema</dfn></dt>
            <dd>The <a data-lt="ShExProcessor.validate.schema">validate.schema</a> argument to <a data-lt="ShExProcessor.validate">validate</a> is invalid.
              <span class="ednote">@gkellogg: This could use some improvement.</span></dd>
            <dt><dfn>non-conforming graph</dfn></dt>
            <dd>The <a data-lt="ShExProcessor.validate.graph">validate.graph</a> is found not to <a>conform</a> with
              <a data-lt="ShExProcessor.validate.schema">validate.schema</a>.</dd>
            <dt><dfn>syntax error</dfn></dt>
            <dd>Parsing <a data-lt="ShExProcessor.validate.schema">validate.schema</a> as
              <a>ShExC</a> failed with a syntax error.</dd>
            <dt><dfn>invalid shape map</dfn></dt>
            <dd>Parsing <a data-lt="ShExProcessor.validate.shapemap">validate.shapemap</a> as
              Shape Map failed with a syntax error.</dd>  
            <dt><dfn>duplicated mapping</dfn></dt>
            <dd>The shape map contains a duplicated mapping</dd>     
            <dt><dfn>URI unresolvable</dfn></dt>
            <dd>Schema or graph can not be resolved at given URI</dd>              
          </dl>
                  <span class="ednote">TODO: the type of error codes could be expanded a bit</span> <br>          
          
        </section>
    </section>

    <section id="shapemap-structure">
      <h2>ShapeMap structure</h2>
      <p class="leadup">
        <dfn data-cite="shex-semantics#dfn-shapemap" data-lt="shapemap|shape-map">ShapeMap</dfn>: a set of pairs of node and shape which may be annotated with the following properties:
      </p>
      <ul class="followup">
        <li class="         leadup"><dfn>node</dfn>: an <a>RDF node</a> or a <a>node selector</a>.</li>
        <li class="followup leadup"><dfn>shape</dfn>: a <a>ShEx shape expression</a>.</li>
        <li class="followup leadup"><dfn>status</dfn>: <em>[default="open"]</em> "open" | "conformant" | "nonconformant".</li>
        <li class="followup leadup"><dfn>negate</dfn>: <em>[default="false"]</em> "false" | "true" </li>
        <li class="followup leadup"><dfn>reason</dfn>: <em>[optional]</em> a string stating a reason for failure or success.</li>
        <li class="followup       "><dfn>appInfo</dfn>: <em>[optional]</em> application-specific JSON-LD structure</li>
      </ul>

      <p>
        To query validation one need to add a set of mapping with the 'open' state to the shape map, 
        which will have either the <code>"conformant"</code> or <code>"nonconformant"</code> status after the validation completed successfully. 
        Mappings with the <code>"conformant"</code> or <code>"nonconformant"</code> status can be added, which informs the validator to take the results as truth, 
        independent of the actual truth. This enables the recycling of validation results of earlier validation process, 
        which can for example be used to only validate elements that have been modified.
      </p>

      <p>
        If the <a>status</a> property is absent, the <a>status</a> is defaulted to be "open".
        The <a>reason</a> and <a>appInfo</a> properties may also be absent but have no default value. 
      </p>

      <p>
        A <dfn>node selector</dfn> is a subset of a <dfn data-cite="sparql11-query#sparqlTriplePatterns">SPARQL triple pattern</dfn> with these restrictions:
      </p>
      <ul>
        <li><code>V</code> (the set of variables) is either a fresh variable or a known token to identify the <a>focus node</a>.</li>
        <li>The focus node token appears in either the subject or the object position.</li>
        <li>The predicate position is filled by an IRI (<code>I</code> in the SPARQL definitions).</li>
      </ul>

      <p>
        The combination of node and shape in a ShapeMap is unique.
        The following would not be a valid ShapeMap:
      </p>

      <aside class="example" title="Invalid ShapeMaps - duplicate node/shape pairs">
        <p>
          This JSON ShapeMap would not be valid as it has two entries for a node/shape pair:
        </p>
        <pre class="error nohighlight">
[
  { "node": "&lt;http://data.example/node1&gt;,
    "shape": "&lt;http://schema.example/Shape2&gt;,
    <span class="lookit">"status": "nonconformant"</span> },
  { "node": "&lt;http://data.example/node1&gt;,
    "shape": "&lt;http://schema.example/Shape2&gt; }
]</pre>
        <p>
          The above example has conflicting values for the <a>status</a>: the first asserts that <code>node1</code> does not conform to <code>Shape2</code>; the second has no status and so asserts the default which is that it does conform.
          The following example is also invalid because it has duplicates even though they do not conflict:
        </p>
        <pre class="error nohighlight">
[
  { "node": "&lt;http://data.example/node1&gt;,
    "shape": "&lt;http://schema.example/Shape2&gt; },
  { "node": "&lt;http://data.example/node1&gt;,
    "shape": "&lt;http://schema.example/Shape2&gt; }
]</pre>
      </aside>
      
    </section>

    <section id="usage">
      <h2>ShapeMap usage</h2>
      <p>
        ShapeMaps are designed to address three purposes in the process of validation an RDF node against a ShEx schema.
      </p>

      <ul>
        <li><dfn>goal</dfn> - the question posed, e.g. "does node1 conform to shape2?"</li>
        <li><dfn>premise</dfn> - the assumptions, e.g. "assume node3 conforms to shape4."</li>
        <li><dfn>result</dfn> - the outcome of a conformance check, e.g. "node1 conforms to shape2."</li>
      </ul>

      <p>
        ShEx 2 does not define the use of premises in validation.
        In principle, the information in a premise would be identical to that in a result.
        It is expected that future work on federating validation will formalize this and provide a standard API.
      </p>

      <h4>@@use cases to consider@@</h4>
      <ul>
        <li> node/shape pair<br/>
        <code>validate(schema, data, node, shape) => result</code>
        <ul>
          <li> result is T/F </li>
          <li> result is ShapeMap
          <ul>
            <li> return orig ShapeMap with status </li>
            <li> return orig ShapeMap with status plus related nodes
            <ul>
              <li> related nodes = all NodeConstraints and Shapes<br/>
              <code>n1@s1,n1@s2!</code>
              </li>
              <li> related nodes = labeled NodeConstraints and Shapes </li>
              <li> related nodes = labeled Shapes </li>
              <li> related nodes = coreferenced Shapes </li>
            </ul></li>
          </ul></li>
        </ul></li>
        <li> set of node/shape pair<br/>
        <code>validate(schema, data, question) => results</code>
        </li>
        <li> long-running process </li>
        <li> ShapeMap as premise<br/>
        <code>validate(schema, data, premise, question) => results</code><br/>
        where premise, coverage and results are all subsets of the full structure.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>ShapeMap syntax</h2>
      <p>
        ShapeMaps can be easily transmitted an understood with a specialized syntax.
      </p>
      <aside class="example" title="Simple human-syntax ShapeMap">
        <p>
          A simple <a>query ShapeMap</a> might look like
        </p>
        <pre class="nohighlight">&lt;http://data.example/#n1&gt; @ &lt;http://data.example/#s&gt;? <span class="comment"># a simple node/shape pair</span>
</pre>
        <p>
          and a response might look like if there were no errors.
        </p>
        <pre class="nohighlight">&lt;http://data.example/#n1&gt; @ &lt;http://data.example/#s&gt; <span class="comment"># a validated node/shape pair</span>
</pre>
      </aside>

      <p>
        Relative and prefixed IRIs in the node position are resolved against the application-defined prefix map and base URL for the data.
        Likewise, schema IRI forms are resolved against the Schema PREFIX and namespace.
      </p>

      <aside class="example" title="ShapeMap with prefixed names">
        <pre class="nohighlight">d:n1 @ s:S1? <span class="comment"># d: prefix from data, s: from schema</span>
</pre>
      </aside>

      <p>
        ... <a>status</a>, <a>reason</a>, <a>appInfo</a> ...
      </p>

      <div class="example">
        <pre class="nohighlight">d:n1 @ s:S1, <span class="comment"># d:n1 validates to shape s:S1</span>
"foo"^^xsd:string@START!           <span class="comment"># "foo" did not match the start shape.</span>
  /"missing :p1"                   <span class="comment"># The reason given is "missing :p1".</span>
  $"appinfo":{"myextra1":["..."]} ,<span class="comment"># The application provide structural data.</span>
"chat"@en-fr@&lt;http://...S3&gt;?, <span class="comment"># please validate a literal against shape S3</span>
{<span class="keyword">FOCUS</span> :p2 "abcd"@en-us}@START, <span class="comment"># validate subjects of :p2 "abcd"</span>
{_ :p3 <span class="keyword">FOCUS</span>}@START <span class="comment"># valide all objects of :p3</span></pre>
      </div>
      <ul>
        <li>The <a>node</a> or <a>node selector</a> is before the '@'.</li>
        <li>The <a>shape expression</a> label is immediately after the '@'.</li>
        <li>The '<code>!</code>' in front of the <a>shape expression</a> means the validation process is negated</li>  
        <li>The '<code>!</code>' after the <a>shape expression</a> means <a>node</a> does not conform to the <a>shape expression</a>.</li>
        <li>The '<code>?</code>' after the <a>shape expression</a> means <a>node</a> means that conformance has not been tested or is pending if validation is performed asynchronously.</li>
        <li>The absense of '<code>!</code>' or '<code>?</code>' after the <a>shape expression</a> means that <a>node</a> conforms to the <a>shape expression</a>.</li>
        <li>The '<code>/</code>' character introduces a url-encoded reason string.</li>
        <li>The '<code>$</code>' character precedes a JSON string which precedes the '<code>:</code>' character and a JSON value. At present, the only string permitted here is <code>"appinfo"</code>.</li>
      </ul>
    </section>

    <section id="grammar">
      <h2>ShapeMap grammar</h2>
      <div class="grammarTable">
<table style="border: 0; border-top: thick solid white; ">

<tbody class="prod">
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">1</span>]   </td>   <td><code class="production prod">shapeMap</code></td>       <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-pair">pair</a></span> (',' <span class="prod"><a class="grammarRef" href="#prod-pair">pair</a></span>)*;</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">2</span>]   </td>   <td><code class="production prod">pair</code></td>           <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-nodeSelector">nodeSelector</a></span> '@' <span class="prod"><a class="grammarRef" href="#prod-nodeSelector">negate</a></span>? <span class="prod"><a class="grammarRef" href="#prod-shapeSelector">shapeSelector</a></span> <span class="prod"><a class="grammarRef" href="#prod-status">status</a></span>? <span class="prod"><a class="grammarRef" href="#prod-reason">reason</a></span>? <span class="prod"><a class="grammarRef" href="#prod-jsonAttributes">jsonAttributes</a></span>?</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">3</span>]   </td>   <td><code class="production prod">nodeSelector</code></td>   <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-objectTerm">objectTerm</a></span> | <span class="prod"><a class="grammarRef" href="#prod-triplePattern">triplePattern</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">4</span>]   </td>   <td><code class="production prod">subjectTerm</code></td>    <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#term-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">5</span>]   </td>   <td><code class="production prod">objectTerm</code></td>     <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-subjectTerm">subjectTerm</a></span> | <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">6</span>]   </td>   <td><code class="production prod">triplePattern</code></td>  <td>   ::=   </td><td><code class="content">'{' "FOCUS" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> (<span class="prod"><a class="grammarRef" href="#prod-objectTerm">objectTerm</a></span> | '_') '}'<br/>
                                                                                                                                                                         | '{' (<span class="prod"><a class="grammarRef" href="#prod-subjectTerm">subjectTerm</a></span> | '_') <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> "FOCUS" '}'</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">7</span>]   </td>   <td><code class="production prod">shapeSelector</code></td>  <td>   ::=   </td><td><code class="content">(<span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | "START") | <span class="prod"><a class="grammarRef" href="#term-ATSTART">ATSTART</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_NS">ATPNAME_NS</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_LN">ATPNAME_LN</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">8</span>]   </td>   <td><code class="production prod">status</code></td>         <td>   ::=   </td><td><code class="content">'!' | '?'</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">9</span>]   </td>   <td><code class="production prod">reason</code></td>         <td>   ::=   </td><td><code class="content">'/' <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">10</span>]   </td>  <td><code class="production prod">jsonAttributes</code></td> <td>   ::=   </td><td><code class="content">'$' '"<span class="prod"><a class="grammarRef" href="#prod-appinfo">appinfo</a></span>"' ':' <span class="prod"><a class="grammarRef" href="#prod-jsonValue">jsonValue</a></span></code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">11</span>]   </td>  <td><code class="production prod">jsonValue</code></td>      <td>   ::=   </td><td><code class="content">'<span class="prod"><a class="grammarRef" href="#prod-false">false</a></span>' | '<span class="prod"><a class="grammarRef" href="#prod-null">null</a></span>' | '<span class="prod"><a class="grammarRef" href="#prod-true">true</a></span>' | <span class="prod"><a class="grammarRef" href="#prod-jsonObject">jsonObject</a></span> | <span class="prod"><a class="grammarRef" href="#prod-jsonArray">jsonArray</a></span> | <span class="prod"><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL2">STRING_LITERAL2</a></span>;</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">12</span>]   </td>  <td><code class="production prod">jsonObject</code></td>     <td>   ::=   </td><td><code class="content">'{' (<span class="prod"><a class="grammarRef" href="#prod-jsonMember">jsonMember</a></span> (',' <span class="prod"><a class="grammarRef" href="#prod-jsonMember">jsonMember</a></span>)*)? '}';</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">13</span>]   </td>  <td><code class="production prod">jsonMember</code></td>     <td>   ::=   </td><td><code class="content"><span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL2">STRING_LITERAL2</a></span> ':' <span class="prod"><a class="grammarRef" href="#prod-jsonValue">jsonValue</a></span>;</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">14</span>]   </td>  <td><code class="production prod">jsonArray</code></td>      <td>   ::=   </td><td><code class="content">'[' (<span class="prod"><a class="grammarRef" href="#prod-jsonValue">jsonValue</a></span> (',' <span class="prod"><a class="grammarRef" href="#prod-jsonValue">jsonValue</a></span>)*)? ']';</code></td></tr>
<tr style="vertical-align: baseline"><td id="prod-literal">[<span class="prodNo">174</span>]   </td>  <td><code class="production prod">negate</code></td>         <td>   ::=   </td><td><code class="content">'!'</code></td></tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-literal">[<span class="prodNo">13t</span>]   </td>
<td><code class="production prod">literal</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-rdfLiteral">rdfLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-numericLiteral">numericLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-booleanLiteral">booleanLiteral</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-numericLiteral">[<span class="prodNo">16t</span>]   </td>
<td><code class="production prod">numericLiteral</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> | <span class="prod"><a class="grammarRef" href="#term-DECIMAL">DECIMAL</a></span> | <span class="prod"><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-rdfLiteral">[<span class="prodNo">65</span>]   </td>
<td><code class="production prod">rdfLiteral</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-langString">langString</a></span> | <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span> ("^^" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span>)?</code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-booleanLiteral">[<span class="prodNo">134s</span>]   </td>
<td><code class="production prod">booleanLiteral</code></td>
<td>   ::=   </td>
<td><code class="content">"true" | "false"</code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-string">[<span class="prodNo">135s</span>]   </td>
<td><code class="production prod">string</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL1">STRING_LITERAL1</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL2">STRING_LITERAL2</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-langString">[<span class="prodNo">66</span>]   </td>
<td><code class="production prod">langString</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#term-LANG_STRING_LITERAL1">LANG_STRING_LITERAL1</a></span> | <span class="prod"><a class="grammarRef" href="#term-LANG_STRING_LITERAL_LONG1">LANG_STRING_LITERAL_LONG1</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-LANG_STRING_LITERAL2">LANG_STRING_LITERAL2</a></span> | <span class="prod"><a class="grammarRef" href="#term-LANG_STRING_LITERAL_LONG2">LANG_STRING_LITERAL_LONG2</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-iri">[<span class="prodNo">136s</span>]   </td>
<td><code class="production prod">iri</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span> | <span class="prod"><a class="grammarRef" href="#prod-prefixedName">prefixedName</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr style="vertical-align: baseline">
<td id="prod-prefixedName">[<span class="prodNo">137s</span>]   </td>
<td><code class="production prod">prefixedName</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_LN">PNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span></code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td colspan="4">
    <h3 id="terminals">Terminals</h3>
  </td></tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-IRIREF">[<span class="prodNo">18t</span>]   </td>
<td>&lt;<code class="production term">IRIREF</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"&lt;" ([^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "&gt;"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PNAME_NS">[<span class="prodNo">140s</span>]   </td>
<td>&lt;<code class="production term">PNAME_NS</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PNAME_LN">[<span class="prodNo">141s</span>]   </td>
<td>&lt;<code class="production term">PNAME_LN</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-ATPNAME_NS">[<span class="prodNo">70</span>]   </td>
<td>&lt;<code class="production term">ATPNAME_NS</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-ATPNAME_LN">[<span class="prodNo">71</span>]   </td>
<td>&lt;<code class="production term">ATPNAME_LN</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-BLANK_NODE_LABEL">[<span class="prodNo">142s</span>]   </td>
<td>&lt;<code class="production term">BLANK_NODE_LABEL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"_:" (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | [0-9]) ((<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span>)?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-AT_PNAME_NS">[<span class="prodNo">15</span>]   </td>
<td>&lt;<code class="production term">AT_PNAME_NS</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'@' <span class="prod"><a class="grammarRef" href="#term-PN_PNAME_NS">PNAME_NS</a></span></code></td>
</tr>
<tr style="vertical-align: baseline">
<td id="term-AT_PNAME_LN">[<span class="prodNo">16</span>]   </td>
<td>&lt;<code class="production term">AT_PNAME_LN</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'@' <span class="prod"><a class="grammarRef" href="#term-PN_PNAME_LN">PNAME_LN</a></span></code></td>
</tr>
<tr style="vertical-align: baseline">
<td id="term-AT_START">[<span class="prodNo">17</span>]   </td>
<td>&lt;<code class="production term">AT_START</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@START"</code></td>
</tr>
    <tr><td colspan="4">This terminal has precendence over <a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></td></tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-LANGTAG">[<span class="prodNo">145s</span>]   </td>
<td>&lt;<code class="production term">LANGTAG</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-INTEGER">[<span class="prodNo">19t</span>]   </td>
<td>&lt;<code class="production term">INTEGER</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? [0-9]+</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-DECIMAL">[<span class="prodNo">20t</span>]   </td>
<td>&lt;<code class="production term">DECIMAL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? [0-9]* "." [0-9]+</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-DOUBLE">[<span class="prodNo">21t</span>]   </td>
<td>&lt;<code class="production term">DOUBLE</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? ([0-9]+ "." [0-9]* <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span> | "."? [0-9]+ <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span>)</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-EXPONENT">[<span class="prodNo">155s</span>]   </td>
<td>&lt;<code class="production term">EXPONENT</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[eE] [+-]? [0-9]+</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-STRING_LITERAL1">[<span class="prodNo">156s</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'" ([^'\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "'"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-STRING_LITERAL2">[<span class="prodNo">157s</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"' ([^\"\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* '"'</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-STRING_LITERAL_LONG1">[<span class="prodNo">158s</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'''" ( ("'" | "''")? ([^\\'\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* "'''"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-STRING_LITERAL_LONG2">[<span class="prodNo">159s</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"""' ( ('"' | '""')? ([^\"\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* '"""'</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-LANG_STRING_LITERAL1">[<span class="prodNo">73</span>]   </td>
<td>&lt;<code class="production term">LANG_STRING_LITERAL1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'" ([^'\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "'" <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-LANG_STRING_LITERAL2">[<span class="prodNo">74</span>]   </td>
<td>&lt;<code class="production term">LANG_STRING_LITERAL2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"' ([^\"\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* '"' <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-LANG_STRING_LITERAL_LONG1">[<span class="prodNo">75</span>]   </td>
<td>&lt;<code class="production term">LANG_STRING_LITERAL_LONG1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'''" ( ("'" | "''")? ([^\\'\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* "'''" <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-LANG_STRING_LITERAL_LONG2">[<span class="prodNo">76</span>]   </td>
<td>&lt;<code class="production term">LANG_STRING_LITERAL_LONG2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"""' ( ('"' | '""')? ([^\"\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* '"""' <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-UCHAR">[<span class="prodNo">26t</span>]   </td>
<td>&lt;<code class="production term">UCHAR</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content">"\\u" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span><br/>
| "\\U" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-ECHAR">[<span class="prodNo">160s</span>]   </td>
<td>&lt;<code class="production term">ECHAR</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"\\" [tbnrf\\\"\\']</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_CHARS_BASE">[<span class="prodNo">164s</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS_BASE</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content">[A-Z] | [a-z]<br/>
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]<br/>
| [#0370-#037D] | [#037F-#1FFF]<br/>
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]<br/>
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]<br/>
| [#10000-#EFFFF]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_CHARS_U">[<span class="prodNo">165s</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS_U</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> | "_"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_CHARS">[<span class="prodNo">167s</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | "-" | [0-9]<br/>
| [#00B7] | [#0300-#036F] | [#203F-#2040]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_PREFIX">[<span class="prodNo">168s</span>]   </td>
<td>&lt;<code class="production term">PN_PREFIX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_LOCAL">[<span class="prodNo">169s</span>]   </td>
<td>&lt;<code class="production term">PN_LOCAL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">(<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | ":" | [0-9] | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | "." | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>)* (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PLX">[<span class="prodNo">170s</span>]   </td>
<td>&lt;<code class="production term">PLX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PERCENT">PERCENT</a></span> | <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL_ESC">PN_LOCAL_ESC</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PERCENT">[<span class="prodNo">171s</span>]   </td>
<td>&lt;<code class="production term">PERCENT</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"%" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-HEX">[<span class="prodNo">172s</span>]   </td>
<td>&lt;<code class="production term">HEX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[0-9] | [A-F] | [a-f]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PN_LOCAL_ESC">[<span class="prodNo">173s</span>]   </td>
<td>&lt;<code class="production term">PN_LOCAL_ESC</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&amp;" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )</code></td>
</tr>
</tbody>

<tbody class="term">
<tr style="vertical-align: baseline">
<td id="term-PASSED_TOKENS">[<span class="prodNo">98</span>]   </td>
<td><code class="production directive">PASSED TOKENS</code></td>
<td>   ::=   </td>
<td>   <code class="content">[ \t\r\n]+<br/>
| "#" [^\r\n]*</code></td>
</tr>
</tbody>

</table>
      </div>
    </section>
  </body>
</html>
